defmodule StEl do # StructuredElement
  defstruct [:type, :els]
  @type t :: %__MODULE__{type: element_type(), els: list(Token.t())}

  @type element_type :: :class | :class_var_dec | :subroutine_dec | :parameter_list | :subroutine_body |
    :var_dec | :statements | :while_statement | :if_statement | :return_statement | :let_statement | :do_statement |
    :expression | :term | :expression_list

  defimpl Inspect, for: StEl do
    import Inspect.Algebra

    def inspect(%StEl{type: type, els: els}, opts) do
      concat(["#{type} {", to_doc(els, opts), "}"])
    end
  end
end

defmodule Jack.Engine do
  @moduledoc """
  Effects the actual compilation output. Gets its input from a
  JackTokenizer and emits its parsed structure into an output file/stream. The
  output is generated by a series of compilexxx() routines, one for every syntactic
  element xxx of the Jack grammar. The contract between these routines is that each
  compilexxx() routine should read the syntactic construct xxx from the input,
  advance() the tokenizer exactly beyond xxx, and output the parsing of xxx. Thus,
  compilexxx() may only be called if indeed xxx is the next syntactic element of the
  input.

  CompileClass            Compiles a complete class.
  CompileClassVarDec      Compiles a static declaration or a field declaration.
  CompileSubroutine       Compiles a complete method, function, or constructor.
  compileParameterList    Compiles a (possibly empty) parameter list, not including the enclosing ‘‘()’’.
  compileVarDec           Compiles a var declaration.
  compileStatements       Compiles a sequence of statements, not including the enclosing ‘‘{}’’.
  compileDo               Compiles a do statement.
  compileLet              Compiles a let statement.
  compileWhile            Compiles a while statement.
  compileReturn           Compiles a return statement.
  compileIf               Compiles an if statement, possibly with a trailing else clause.
  CompileExpression       Compiles an expression.
  CompileTerm             Compiles a term. This routine is faced with a slight difficulty
                            when trying to decide between some of the alternative parsing
                            rules. Specifically, if the current token is an identifier, the routine
                            must distinguish between a variable, an array entry, and a
                            subroutine call. A single lookahead token, which may be one
                            of ‘‘[’’, ‘‘(’’, or ‘‘.’’ suffices to distinguish between the three possibilities.
                            Any other token is not part of this term and should not be advanced over.
  CompileExpressionList   Compiles a (possibly empty) comma-separated list of expressions.

  Non Terminal groupings:
  * class, classVarDec, subroutineDec, parameterList, subroutineBody, varDec;
  * statements, whileSatement, ifStatement, returnStatement, letStatement, doStatement;
  * expression, term, expressionList.

  Terminal Groupings
  * keyword, symbol, integerConstant, stringConstant, or identifier.
  """

  @doc """
  This will always be called first. The first
  """
  def compile([%Tk{val: :class} = class, class_name = %Tk{type: :identifier}, br = %Tk{val: "{"} | tokens], acc) do
    # Class declaration.
    # Class class_name { class_variable*, subroutine* }
    {remaining_tokens, class_elements} = compile_until_greedy(tokens, "}")
    {remaining_tokens, [%StEl{type: :class, els: [class, class_name, br] ++ Enum.reverse(class_elements) }] ++ acc}
  end


  def compile([%Tk{type: :keyword, val: val} = var_dec, type, name | tokens], acc) when val in [:field, :static] do
    # Class variable declaration.
    # field int x, y;
    {remaining_tokens, more_var_dec_elements} = compile_until_greedy(tokens, ";")
    # IO.inspect(remaining_tokens, label: :rem_toks)
    # IO.inspect(more_var_dec_elements, label: :more_var_decs)
    {remaining_tokens, [%StEl{type: :class_var_dec, els: [var_dec, type, name] ++ Enum.reverse(more_var_dec_elements)}] ++ acc}
  end

  def compile([%Tk{type: :keyword, val: val} = rt_type, ret_type, name, br = %Tk{val: "("} | tokens], acc) when val in [:constructor, :function, :method, :void] do
    # Subroutine declaration.
    # ('constructor' | 'function' | 'method')
    # ('void' | type) subroutineName '(' parameterList ')'
    # subroutineBody

    # Apparently a parameter list doesn't include the braces ¯\_(ツ)_/¯
    {[%Tk{val: ")"} = cl, %Tk{val: "{"} = ob | remaining_tokens], parameter_list_tokens} = compile_until_no_greedy(tokens, ")")
    parameter_list = [%StEl{type: :parameter_list, els: Enum.reverse(parameter_list_tokens)}]

    # Build ourselves a subroutine body
    {body_remaining_tokens, subroutine_body_tokens} = compile_until_greedy(remaining_tokens, "}")
    subroutine_body = [%StEl{type: :subroutine_body, els: [ob] ++ Enum.reverse(subroutine_body_tokens)}]

    {body_remaining_tokens, [%StEl{type: :subroutine_dec, els: [rt_type, ret_type, name, br] ++ parameter_list ++ [cl] ++ Enum.reverse(subroutine_body)}] ++ acc}
  end


  def compile([%Tk{type: type} = el | tokens], acc) when type in [:comment, :identifier, :keyword] do
    compile(tokens, [el | acc])
  end

  def compile([%Tk{val: ","} = comma | tokens], acc) do
    compile(tokens, [comma | acc])
  end

  def compile([%Tk{val: val} | _] = tokens, acc) when val in ["}", ";", ")"] do
    {tokens, acc}
  end

  def compile([], acc), do: {[], Enum.reverse(acc)}


  @doc """
  Calls compile until we have the specified token returned at the end.
  Removes it and appends it to the head of the accumulator.
  """
  def compile_until_greedy(tokens, val) do
    {[tk | tokens], acc} = compile_until_no_greedy(tokens, val)
    {tokens, [tk | acc]}
  end

  @doc """
  Calls compile until the specified token is found at the start of `remaining_tokens`. Leaves the token
  at the head of `remaining_tokens`.
  """
  def compile_until_no_greedy([%Tk{} | _] = tokens, val), do: compile_until_no_greedy({tokens, []}, val)
  def compile_until_no_greedy({[%Tk{val: val} | _] = tokens, acc}, val) do
    {tokens, acc}
  end

  def compile_until_no_greedy({tokens, acc}, tk) do
    tokens
    |> compile(acc)
    |> compile_until_no_greedy(tk)
  end
end
