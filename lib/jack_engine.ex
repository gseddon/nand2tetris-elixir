defmodule StEl do # StructuredElement
  defstruct [:type, :els]
  @type t :: %__MODULE__{type: element_type(), els: list(Token.t())}

  @type element_type :: :class | :class_var_dec | :subroutine_dec | :parameter_list | :subroutine_body |
    :var_dec | :statements | :while_statement | :if_statement | :return_statement | :let_statement | :do_statement |
    :expression | :term | :expression_list
end

defmodule Jack.Engine do
  @moduledoc """
  Effects the actual compilation output. Gets its input from a
  JackTokenizer and emits its parsed structure into an output file/stream. The
  output is generated by a series of compilexxx() routines, one for every syntactic
  element xxx of the Jack grammar. The contract between these routines is that each
  compilexxx() routine should read the syntactic construct xxx from the input,
  advance() the tokenizer exactly beyond xxx, and output the parsing of xxx. Thus,
  compilexxx() may only be called if indeed xxx is the next syntactic element of the
  input.

  CompileClass            Compiles a complete class.
  CompileClassVarDec      Compiles a static declaration or a field declaration.
  CompileSubroutine       Compiles a complete method, function, or constructor.
  compileParameterList    Compiles a (possibly empty) parameter list, not including the enclosing ‘‘()’’.
  compileVarDec           Compiles a var declaration.
  compileStatements       Compiles a sequence of statements, not including the enclosing ‘‘{}’’.
  compileDo               Compiles a do statement.
  compileLet              Compiles a let statement.
  compileWhile            Compiles a while statement.
  compileReturn           Compiles a return statement.
  compileIf               Compiles an if statement, possibly with a trailing else clause.
  CompileExpression       Compiles an expression.
  CompileTerm             Compiles a term. This routine is faced with a slight difficulty
                            when trying to decide between some of the alternative parsing
                            rules. Specifically, if the current token is an identifier, the routine
                            must distinguish between a variable, an array entry, and a
                            subroutine call. A single lookahead token, which may be one
                            of ‘‘[’’, ‘‘(’’, or ‘‘.’’ suffices to distinguish between the three possibilities.
                            Any other token is not part of this term and should not be advanced over.
  CompileExpressionList   Compiles a (possibly empty) comma-separated list of expressions.

  Non Terminal groupings:
  * class, classVarDec, subroutineDec, parameterList, subroutineBody, varDec;
  * statements, whileSatement, ifStatement, returnStatement, letStatement, doStatement;
  * expression, term, expressionList.

  Terminal Groupings
  * keyword, symbol, integerConstant, stringConstant, or identifier.
  """

  @doc """
  This will always be called first. The first
  """
  def compile([%Tk{val: :class} = class, class_name = %Tk{type: :identifier}, br = %Tk{val: "{"} | tokens], acc) do
    {remaining_tokens, class_elements} = compile_until(tokens, "}")
    {remaining_tokens, acc ++ [%StEl{type: :class, els: [class, class_name, br] ++ class_elements}]}
  end


  def compile([], acc), do: {[], Enum.reverse(acc)}

  def compile([%Tk{type: :keyword, val: val} = var_dec, type, name | tokens], acc) when val in [:field, :static] do
    # Class variable declaration.
    # field int x, y;
    {remaining_tokens, more_var_dec_elements} = compile_until(tokens, ";")
    {remaining_tokens, acc ++ %StEl{type: :class_var_dec, els: [var_dec, type, name] ++ more_var_dec_elements}}
  end

  def compile([%Tk{val: val} | _] = tokens, acc) when val in ["}", ";", ")"] do
    {tokens, Enum.reverse(acc)}
  end


  def compile([%Tk{type: :comment} = comment | tokens], acc) do
    compile(tokens, acc ++ [comment])
  end

  def compile([%Tk{type: :identifier} = identifier | tokens], acc) do
    compile(tokens, acc ++ [identifier])
  end

  def compile([%Tk{val: ","} = comma | tokens], acc) do
    compile(tokens, acc ++ [comma])
  end


  def compile_until([%Tk{} | _] = tokens, val), do: compile_until({tokens, []}, val)
  def compile_until({[%Tk{val: val} | tokens], acc}, val) do
    {tokens, acc}
  end

  def compile_until({tokens, acc}, tk) do
    tokens
    |> compile(acc)
    |> compile_until(tk)
  end
end
